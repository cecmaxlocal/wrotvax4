Of course! The "COW" (Component, Objective, Workings) methodology is an excellent, straightforward way to document software components. It focuses on clarity and purpose.

Since `main.yacc` is a parser definition file (for Yacc or Bison), we'll document it as a single, core component of a larger application (like a command-line calculator or a simple language interpreter).

Here is the COW documentation for a hypothetical but representative `main.yacc` file that defines a parser for an advanced calculator.

***

# COW Documentation: `main.yacc`

This document follows the Component-Objective-Workings (COW) methodology to describe the `main.yacc` parser file.

## Component: Arithmetic Expression Parser

The `main.yacc` file defines a parser generated by GNU Bison (or Yacc). This parser is the central component for understanding and processing user input in our command-line calculator. It forms the "brain" of the application, responsible for interpreting the structure and meaning of mathematical statements.

---

## Objective

The primary objective of this parser is to **recognize, parse, and evaluate multi-line arithmetic expressions, including variable assignments and lookups.**

It is designed to transform a linear stream of tokens (provided by a lexical analyzer like `lex` or `flex`) into a final, calculated numerical value or an error message.

### Key Features & Goals:

*   **Standard Arithmetic:** Correctly evaluate expressions with `+` (addition), `-` (subtraction), `*` (multiplication), and `/` (division).
*   **Operator Precedence:** Enforce the standard mathematical order of operations (e.g., multiplication before addition).
*   **Associativity:** Correctly handle chains of operators (e.g., `10 - 5 - 2` is evaluated left-to-right).
*   **Grouping:** Allow users to override precedence with parentheses `( ... )`.
*   **Unary Operations:** Support unary minus for negative numbers (e.g., `-5` or `-(10 * 2)`).
*   **Variable Support:**
    *   Allow assignment of values to single-letter variables (e.g., `a = 10`).
    *   Allow variables to be used in subsequent expressions (e.g., `a * 2`).
*   **Error Handling:** Provide meaningful syntax error messages to the user.

---

## Workings

This section details *how* the parser achieves its objective.

### 1. Dependencies

The parser does not operate in isolation. It relies on:

*   **`lexical_analyzer.l` (Flex file):** A lexical analyzer is required to scan the raw input string and break it down into a stream of tokens. The parser consumes these tokens one by one.
*   **`yylex()` function:** This is the interface to the lexer. The parser calls `yylex()` whenever it needs the next token.
*   **`yyerror(char *s)` function:** A C function that the parser calls automatically upon encountering a syntax error. We must provide an implementation for it to print the error message.
*   **Symbol Table:** A simple data structure (e.g., an array) to store the values of assigned variables.
*   **`main()` function:** An entry point in a separate C file (`main.c`) that initializes the system and starts the parsing process by calling `yyparse()`.

### 2. Expected Tokens

The parser expects the lexer to provide the following tokens. The interface between lexer and parser is a critical contract.

| Token Name | C Type         | RegEx (Example) | Description                               |
| :--------- | :------------- | :-------------- | :---------------------------------------- |
| `NUMBER`   | `double`       | `[0-9]+(\.[0-9]+)?` | Represents a floating-point number.       |
| `VAR`      | `int`          | `[a-zA-Z]`      | Represents a single-character variable name. The value is an index (e.g., 'a' -> 0). |
| `ASSIGN`   | (none)         | `=`             | The assignment operator.                    |
| `EOL`      | (none)         | `\n`            | The end-of-line character.                |
| *Literals* | (none)         | `+`, `-`, `*`, `/`, `(`, `)` | Single-character operators and parentheses are passed as themselves. |

### 3. Grammar Rules & Structure

The core of the parser is its context-free grammar. The grammar is defined hierarchically to handle operator precedence and structure.

#### Operator Precedence and Associativity

Precedence is defined from lowest to highest. Operators on the same line have the same precedence.

1.  `%left ASSIGN` (Assignment, lowest precedence)
2.  `%left '+' '-'` (Addition/Subtraction)
3.  `%left '*' '/'` (Multiplication/Division)
4.  `%right UMINUS` (Unary Minus, highest precedence)

`%left` means the operators are left-associative (e.g., `a-b-c` is `(a-b)-c`).
`%right` means the operators are right-associative.

#### Key Grammar Rules

The parser logic flows from the top-level rule (`lines`) down to the simplest elements (`NUMBER`).

*   **`lines`**: The start symbol. It can be an empty input, or a list of lines followed by another line. This allows for multi-line input.
    ```yacc
    lines: /* empty */ | lines line ;
    ```

*   **`line`**: A single line of input can be either just a newline (an empty line) or an expression followed by a newline.
    ```yacc
    line: EOL | expr EOL { printf("= %g\n", $1); };
    ```
    The C code in `{...}` is a **semantic action**. This action prints the final result of the expression on that line.

*   **`expr`**: This is where the main logic resides.
    *   **Assignment:** `VAR ASSIGN expr`
        *   This rule matches patterns like `a = 5 * 2`. The semantic action for this rule will store the result of the right-hand side expression (`$3`) into the symbol table at the index represented by the variable (`$1`).
    *   **Arithmetic:** `expr '+' expr`, `expr '-' expr`, etc.
        *   These rules match binary operations. The semantic action performs the actual calculation. For example, in `expr: expr '+' expr { $$ = $1 + $3; };`, the value of the first expression (`$1`) is added to the value of the second expression (`$3`), and the result is assigned to this rule's value (`$$`).
    *   **Grouping:** `( expr )`
        *   This rule simply passes the value of the inner expression up the parse tree (`$$ = $2;`), effectively isolating it from surrounding operators.
    *   **Unary Minus:** `- expr %prec UMINUS`
        *   This rule gives the `-` token a different, higher precedence (`UMINUS`) when it appears before an expression, distinguishing it from binary subtraction. The action is `$$ = -$2;`.

*   **Base Cases:** `NUMBER` | `VAR`
    *   These are the terminals of the grammar. When a `NUMBER` is found, its value is used directly. When a `VAR` is found (in a context other than assignment), its value is looked up in the symbol table.

### 4. Core Data Structures & Functions

*   **Symbol Table (`double sym[26];`)**:
    *   A simple array of 26 doubles is used to store variable values for 'a' through 'z'.
    *   The `VAR` token from the lexer provides an integer index (0 for 'a', 1 for 'b', etc.).
    *   Assignment (`a = 10`) translates to `sym[0] = 10.0;`.
    *   Usage (`a * 2`) translates to `sym[0] * 2.0;`.

*   **`yyparse()`**:
    *   The main function generated by Yacc/Bison. When called, it repeatedly calls `yylex()` to fetch tokens and attempts to match them against the grammar rules. It builds the parse tree and executes semantic actions as rules are completed.

### 5. Example Execution Flow

Consider the input:
```
a = 10
a * 2
```

1.  **Line 1 (`a = 10`)**:
    *   `yylex()` returns `VAR` (with value 0 for 'a'), then `ASSIGN`, then `NUMBER` (with value 10), then `EOL`.
    *   The parser matches the `VAR ASSIGN expr` rule.
    *   The semantic action `{ sym[$1] = $3; }` is executed. `sym[0]` is set to `10`.
    *   The `line` rule is matched. No value is printed for assignments.

2.  **Line 2 (`a * 2`)**:
    *   `yylex()` returns `VAR` (value 0), then `*`, then `NUMBER` (value 2), then `EOL`.
    *   The parser first resolves the `VAR` by looking up `sym[0]`, getting `10`.
    *   It then matches the `expr '*' expr` rule.
    *   The semantic action `{ $$ = $1 * $3; }` is executed, calculating `10 * 2`. The result, `20`, becomes the value of this `expr`.
    *   The `line` rule is matched. Its action `{ printf("= %g\n", $1); }` is executed, printing `= 20` to the console.

***