/* Of course. Here is a well-structured and commented `client.yacc` file.

This example defines the grammar for a simple command-line client, like an 
FTP or a database client. It can parse commands such as `connect`, `get`, `put`, 
`ls`, `help`, and `quit`.

### `client.yacc`

```yacc */
/* ----------------------------------------------------------------- */
/*                             client.yacc                             */
/*                                                                   */
/*  A Yacc/Bison grammar file for a simple command-line client.      */
/*  This parser understands commands like:                             */
/*      connect <host> <port>                                        */
/*      get <filename>                                               */
/*      put <filename>                                               */
/*      ls                                                           */
/*      disconnect                                                   */
/*      help                                                         */
/*      quit / exit                                                  */
/* ----------------------------------------------------------------- */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* External function declarations */
int yylex(void);            // The lexer function generated by Flex
void yyerror(const char *s); // Error reporting function
void print_help(void);       // A custom function to show help text

%}

/* 
 * Define the union of possible data types for tokens and non-terminals.
 * A token can be a string (like a hostname) or an integer (like a port).
 */
%union {
    char *strval;
    int  intval;
}

/* 
 * Define tokens (terminal symbols). The lexer (client.l) will return these.
 * We associate STRING and NUMBER with a data type from the union.
 */
%token <strval> STRING      /* A quoted string or a sequence of non-space chars */
%token <intval> NUMBER      /* An integer */
%token CONNECT DISCONNECT
%token GET PUT LS
%token HELP QUIT EXIT
%token EOL                  /* End of Line token, useful for structure */


%% /* Grammar Rules Start Here */

/* The top-level rule: a session is a sequence of command lines */
session:
    /* empty */
    | session command_line
    ;

/* A command line is a single command followed by an End of Line */
command_line:
    command EOL { printf(">> "); } /* Print a prompt for the next command */
    | error EOL { yyerrok; printf(">> "); } /* Error recovery: skip bad lines */
    ;

/* The 'command' non-terminal defines all valid commands */
command:
    connect_cmd
    | disconnect_cmd
    | get_cmd
    | put_cmd
    | ls_cmd
    | help_cmd
    | quit_cmd
    ;

/* Rule for the 'connect' command */
connect_cmd:
    CONNECT STRING NUMBER {
        printf("Action: Attempting to connect to host '%s' on port %d...\n", $2, $3);
        // In a real client, you would call a function here:
        // handle_connect($2, $3);
        free($2); // IMPORTANT: Free memory allocated by the lexer (e.g., strdup)
    }
    ;

/* Rule for the 'disconnect' command */
disconnect_cmd:
    DISCONNECT {
        printf("Action: Disconnecting from server...\n");
        // handle_disconnect();
    }
    ;

/* Rule for the 'get' command */
get_cmd:
    GET STRING {
        printf("Action: Getting file '%s'...\n", $2);
        // handle_get($2);
        free($2);
    }
    ;

/* Rule for the 'put' command */
put_cmd:
    PUT STRING {
        printf("Action: Putting file '%s'...\n", $2);
        // handle_put($2);
        free($2);
    }
    ;

/* Rule for the 'ls' command */
ls_cmd:
    LS {
        printf("Action: Listing remote directory...\n");
        // handle_ls();
    }
    ;

/* Rule for the 'help' command */
help_cmd:
    HELP {
        print_help();
    }
    ;

/* Rule for the 'quit' or 'exit' command */
quit_cmd:
    QUIT {
        printf("Exiting client.\n");
        exit(0);
    }
    | EXIT {
        printf("Exiting client.\n");
        exit(0);
    }
    ;

%% /* Additional C Code Starts Here */

/* The main entry point of the application */
int main(void) {
    printf("Simple Command Client. Type 'help' for commands.\n");
    printf(">> ");
    yyparse(); // Start the parser
    return 0;
}

/*
 * The error reporting function required by Yacc/Bison.
 * It's called when a syntax error is found.
 */
void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

/*
 * A helper function to print the list of available commands.
 */
void print_help(void) {
    printf("\nAvailable commands:\n");
    printf("  connect <host> <port>  - Connect to a remote server.\n");
    printf("  disconnect             - Disconnect from the current server.\n");
    printf("  get <remote_file>      - Download a file from the server.\n");
    printf("  put <local_file>       - Upload a file to the server.\n");
    printf("  ls                     - List files on the remote server.\n");
    printf("  help                   - Display this help message.\n");
    printf("  quit | exit            - Terminate the client.\n\n");
}

/* ```

### How to Use This File

This `client.yacc` file requires a corresponding lexer file, typically named `client.l`, to generate the tokens.

#### 1. Create the Lexer (`client.l`)

You'll need a Flex file to recognize the keywords, strings, numbers, and newlines.

```lex */
/* client.l - A Flex lexer for client.yacc */
%{
#include "client.yacc.h" // Header generated by Bison with the -d flag
#include <string.h>

/* 
 * The yacc-generated parser will need to access the value of the token.
 * We use yylval (a global variable) for this.
 */
%}

/* Options to handle EOF without warnings */
%option noyywrap

%%

[ \t]+                  /* Ignore whitespace */

"connect"               { return CONNECT; }
"disconnect"            { return DISCONNECT; }
"get"                   { return GET; }
"put"                   { return PUT; }
"ls"                    { return LS; }
"help"                  { return HELP; }
"quit"                  { return QUIT; }
"exit"                  { return EXIT; }

[0-9]+                  { yylval.intval = atoi(yytext); return NUMBER; }

[a-zA-Z0-9\._/-]+       { yylval.strval = strdup(yytext); return STRING; }

\n                      { return EOL; }

.                       { fprintf(stderr, "Error: Unrecognized character '%c'\n", *yytext); }

%%
/* ```

#### 2. Compilation Steps

You will need `bison` (or `yacc`) and `flex` (or `lex`) installed.

1.  **Generate the parser and header file from `client.yacc`:**
    The `-d` flag is important because it creates `client.yacc.h`, which contains the token definitions needed by the lexer.

    ```bash
    bison -d client.yacc
    ```
    This creates `client.yacc.c` and `client.yacc.h`.

2.  **Generate the C source from the lexer file `client.l`:**

    ```bash
    flex client.l
    ```
    This creates `lex.yy.c`.

3.  **Compile and link everything into an executable:**

    ```bash
    gcc -o client client.yacc.c lex.yy.c -lfl
    ```
    (On some systems, you might need `-ll` instead of `-lfl`).

#### 3. Run the Client

Now you can run the compiled program.

```bash
./client
```

You will see a prompt and can start typing commands:

```
Simple Command Client. Type 'help' for commands.
>> connect localhost 8080
Action: Attempting to connect to host 'localhost' on port 8080...
>> get my_document.txt
Action: Getting file 'my_document.txt'...
>> ls
Action: Listing remote directory...
>> help

Available commands:
  connect <host> <port>  - Connect to a remote server.
  disconnect             - Disconnect from the current server.
  get <remote_file>      - Download a file from the server.
  put <local_file>       - Upload a file to the server.
  ls                     - List files on the remote server.
  help                   - Display this help message.
  quit | exit            - Terminate the client.

>> quit
Exiting client.
``` */
